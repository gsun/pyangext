# Generated by Haxe 4.1.1
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
import inspect as python_lib_Inspect
from pyang.plugin import PyangPlugin as pyangext_PyangPlugin
import optparse as pyangext_Optparse
import pyang.plugin as pyangext_Plugin
import pyang.statements as pyangext_Statements
import sys as python_lib_Sys
import functools as python_lib_Functools
import traceback as python_lib_Traceback


def pyang_plugin_init():
    pyangext_Plugin.register_plugin(TreePlugin())
        
class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'



class Class: pass


class Lambda:
    _hx_class_name = "Lambda"
    __slots__ = ()
    _hx_statics = ["has"]

    @staticmethod
    def has(it,elt):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            if HxOverrides.eq(x1,elt):
                return True
        return False


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["isOfType", "string"]

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has



class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["exit", "systemName"]

    @staticmethod
    def exit(code):
        python_lib_Sys.exit(code)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")


class TreePlugin(pyangext_PyangPlugin):
    _hx_class_name = "TreePlugin"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["add_opts", "add_output_format", "emit", "print_help", "setup_ctx", "setup_fmt", "emit_tree", "unexpand_uses", "print_path", "print_children", "print_node", "get_status_str", "get_flags_str", "get_leafref_path", "get_typename"]
    _hx_statics = ["times", "pyang_plugin_init"]
    _hx_interfaces = []
    _hx_super = pyangext_PyangPlugin


    def __init__(self):
        super().__init__("yatree")

    def add_opts(self,optparser):
        optlist = [pyangext_Optparse.make_option("--yatree-help",**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'dest': "tree_help", 'action': "store_true", 'help': "Print help on tree symbols and exit"}))), pyangext_Optparse.make_option("--yatree-depth",**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'type': "int", 'dest': "tree_depth", 'help': "Number of levels to print"}))), pyangext_Optparse.make_option("--yatree-line-length",**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'type': "int", 'dest': "tree_line_length", 'help': "Maximum line length"}))), pyangext_Optparse.make_option("--yatree-path",**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'dest': "tree_path", 'help': "Subtree to print"}))), pyangext_Optparse.make_option("--yatree-print-groupings",**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'dest': "tree_print_groupings", 'action': "store_true", 'help': "Print groupings"}))), pyangext_Optparse.make_option("--yatree-no-expand-uses",**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'dest': "tree_no_expand_uses", 'action': "store_true", 'help': "Do not expand uses of groupings"}))), pyangext_Optparse.make_option("--yatree-module-name-prefix",**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'dest': "modname_prefix", 'action': "store_true", 'help': ("Prefix with module names instead of " + "prefixes")})))]
        g = optparser.add_option_group("Tree output specific options")
        g.add_options(optlist)

    def add_output_format(self,fmts):
        self.multiple_modules = True
        fmts["yatree"] = self

    def emit(self,ctx,modules,writef):
        path = []
        if (Reflect.field(ctx.opts,"tree_path") is not None):
            path = Reflect.field(Reflect.field(ctx.opts,"tree_path"),"split")("/")
            if ((path[0] if 0 < len(path) else None) == ""):
                if (len(path) != 0):
                    path.pop(0)
        tree_depth = (Reflect.field(ctx.opts,"tree_depth") if ((Reflect.field(ctx.opts,"tree_depth") is not None)) else 0)
        tree_line_length = (Reflect.field(ctx.opts,"tree_line_length") if ((Reflect.field(ctx.opts,"tree_line_length") is not None)) else 0)
        self.emit_tree(ctx,modules,writef,tree_depth,tree_line_length,path)

    def print_help(self):
        _hx_str = "\r\n    Each node is printed as:\r\n\r\n    <status>--<flags> <name><opts> <type> <if-features>\r\n\r\n      <status> is one of:\r\n        +  for current\r\n        x  for deprecated\r\n        o  for obsolete\r\n\r\n      <flags> is one of:\r\n        rw  for configuration data\r\n        ro  for non-configuration data, output parameters to rpcs\r\n            and actions, and notification parameters\r\n        -w  for input parameters to rpcs and actions\r\n        -u  for uses of a grouping\r\n        -x  for rpcs and actions\r\n        -n  for notifications\r\n\r\n      <name> is the name of the node\r\n        (<name>) means that the node is a choice node\r\n       :(<name>) means that the node is a case node\r\n\r\n       If the node is augmented into the tree from another module, its\r\n       name is printed as <prefix>:<name>.\r\n\r\n      <opts> is one of:\r\n        ?  for an optional leaf, choice, anydata or anyxml\r\n        !  for a presence container\r\n        *  for a leaf-list or list\r\n        [<keys>] for a list's keys\r\n\r\n        <type> is the name of the type for leafs and leaf-lists, or\r\n               \"<anydata>\" or \"<anyxml>\" for anydata and anyxml, respectively\r\n\r\n        If the type is a leafref, the type is printed as \"-> TARGET\", where\r\n        TARGET is the leafref path, with prefixes removed if possible.\r\n\r\n      <if-features> is the list of features this node depends on, printed\r\n        within curly brackets and a question mark \"{...}?\"\r\n    "
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    def setup_ctx(self,ctx):
        if Reflect.field(ctx.opts,"yatree_help"):
            self.print_help()
            Sys.exit(0)

    def setup_fmt(self,ctx):
        ctx.implicit_errors = False

    def emit_tree(self,ctx,modules,fd,depth,llen,path):
        printed_header = False
        def _hx_local_0(module):
            nonlocal printed_header
            b = module.search_one("belongs-to")
            bstr = (((" (belongs-to " + HxOverrides.stringOrNull(b.arg)) + ")") if ((b is not None)) else "")
            fd.write(((((("" + Std.string(module.keyword)) + ": ") + HxOverrides.stringOrNull(module.arg)) + ("null" if bstr is None else bstr)) + "\n"))
            printed_header = True
        print_header = _hx_local_0
        _g = 0
        while (_g < len(modules)):
            module = (modules[_g] if _g >= 0 and _g < len(modules) else None)
            _g = (_g + 1)
            i_children = (Reflect.field(module,"i_children") if (python_Boot.hasField(module,"i_children")) else list())
            _g1 = []
            _g2 = 0
            while (_g2 < len(i_children)):
                ch = (i_children[_g2] if _g2 >= 0 and _g2 < len(i_children) else None)
                _g2 = (_g2 + 1)
                if Lambda.has(pyangext_Statements.data_definition_keywords,ch.keyword):
                    _g1.append(ch)
            chs = _g1
            chpath = []
            if (len(path) > 0):
                _g3 = []
                _g4 = 0
                while (_g4 < len(chs)):
                    ch1 = (chs[_g4] if _g4 >= 0 and _g4 < len(chs) else None)
                    _g4 = (_g4 + 1)
                    if (ch1.arg == (path[0] if 0 < len(path) else None)):
                        _g3.append(ch1)
                chs = _g3
                chpath = path[1:None]
            if (len(chs) > 0):
                if (not printed_header):
                    print_header(module)
                    printed_header = True
                self.print_children(chs,module,fd,"",chpath,"data",depth,llen,Reflect.field(ctx.opts,"tree_no_expand_uses"),0,Reflect.field(ctx.opts,"modname_prefix"))
            mods = [module]
            _g5 = 0
            _g6 = module.search("include")
            while (_g5 < len(_g6)):
                i = (_g6[_g5] if _g5 >= 0 and _g5 < len(_g6) else None)
                _g5 = (_g5 + 1)
                subm = ctx.get_module(i.arg)
                if (subm is not None):
                    mods.append(subm)
            section_delimiter_printed = False
            _g7 = 0
            while (_g7 < len(mods)):
                m = (mods[_g7] if _g7 >= 0 and _g7 < len(mods) else None)
                _g7 = (_g7 + 1)
                _g8 = 0
                _g9 = m.search("augment")
                while (_g8 < len(_g9)):
                    a = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
                    _g8 = (_g8 + 1)
                    augment = a
                    _this = augment.i_target_node
                    i_module = (Reflect.field(_this,"i_module") if (python_Boot.hasField(_this,"i_module")) else None)
                    if (((i_module is not None) and (not Lambda.has(modules,i_module))) and (not Lambda.has(mods,i_module))):
                        if (not section_delimiter_printed):
                            fd.write("\n")
                            section_delimiter_printed = True
                        if (not printed_header):
                            print_header(module)
                            printed_header = True
                        self.print_path("  augment",":",augment.arg,fd,llen)
                        mode = None
                        _g10 = augment.i_target_node.keyword
                        if (_g10 == "input"):
                            mode = "input"
                        elif (_g10 == "notification"):
                            mode = "notification"
                        elif (_g10 == "output"):
                            mode = "output"
                        else:
                            mode = "augment"
                        self.print_children((Reflect.field(augment,"i_children") if (python_Boot.hasField(augment,"i_children")) else list()),m,fd,"  ",path,mode,depth,llen,Reflect.field(ctx.opts,"tree_no_expand_uses"),0,Reflect.field(ctx.opts,"modname_prefix"))
            _g11 = []
            _g12 = 0
            while (_g12 < len(i_children)):
                ch2 = (i_children[_g12] if _g12 >= 0 and _g12 < len(i_children) else None)
                _g12 = (_g12 + 1)
                if (ch2.keyword == "rpc"):
                    _g11.append(ch2)
            rpcs = _g11
            rpath = []
            if (len(path) > 0):
                _g13 = []
                _g14 = 0
                while (_g14 < len(rpcs)):
                    rpc = (rpcs[_g14] if _g14 >= 0 and _g14 < len(rpcs) else None)
                    _g14 = (_g14 + 1)
                    if (rpc.arg == (path[0] if 0 < len(path) else None)):
                        _g13.append(rpc)
                rpcs = _g13
                rpath = path[1:None]
            if (len(rpcs) > 0):
                if (not printed_header):
                    print_header(module)
                    printed_header = True
                fd.write("\n  rpcs:\n")
                self.print_children(rpcs,module,fd,"  ",rpath,"rpc",depth,llen,Reflect.field(ctx.opts,"tree_no_expand_uses"),0,Reflect.field(ctx.opts,"modname_prefix"))
            _g15 = []
            _g16 = 0
            while (_g16 < len(i_children)):
                ch3 = (i_children[_g16] if _g16 >= 0 and _g16 < len(i_children) else None)
                _g16 = (_g16 + 1)
                if (ch3.keyword == "notification"):
                    _g15.append(ch3)
            notifs = _g15
            npath = []
            if (len(path) > 0):
                _g17 = []
                _g18 = 0
                while (_g18 < len(notifs)):
                    n = (notifs[_g18] if _g18 >= 0 and _g18 < len(notifs) else None)
                    _g18 = (_g18 + 1)
                    if (n.arg == (path[0] if 0 < len(path) else None)):
                        _g17.append(n)
                notifs = _g17
                npath = path[1:None]
            if (len(notifs) > 0):
                if (not printed_header):
                    print_header(module)
                    printed_header = True
                fd.write("\n  notifications:\n")
                self.print_children(notifs,module,fd,"  ",npath,"notification",depth,llen,Reflect.field(ctx.opts,"tree_no_expand_uses"),0,Reflect.field(ctx.opts,"modname_prefix"))
            if Reflect.field(ctx.opts,"tree_print_groupings"):
                section_delimiter_printed = False
                _g19 = 0
                while (_g19 < len(mods)):
                    m1 = (mods[_g19] if _g19 >= 0 and _g19 < len(mods) else None)
                    _g19 = (_g19 + 1)
                    _g20 = 0
                    _g21 = m1.search("grouping")
                    while (_g20 < len(_g21)):
                        g = (_g21[_g20] if _g20 >= 0 and _g20 < len(_g21) else None)
                        _g20 = (_g20 + 1)
                        if (not printed_header):
                            print_header(module)
                            printed_header = True
                        if (not section_delimiter_printed):
                            fd.write("\n")
                            section_delimiter_printed = True
                        fd.write((("  grouping " + HxOverrides.stringOrNull(g.arg)) + "\n"))
                        self.print_children((Reflect.field(g,"i_children") if (python_Boot.hasField(g,"i_children")) else list()),m1,fd,"  ",path,"grouping",depth,llen,Reflect.field(ctx.opts,"tree_no_expand_uses"),0,Reflect.field(ctx.opts,"modname_prefix"))
            if Reflect.field(ctx.opts,"tree_print_yang_data"):
                yds = module.search(("ietf-restconf", "yang-data"))
                if (len(yds) > 0):
                    if (not printed_header):
                        print_header(module)
                        printed_header = True
                    section_delimiter_printed = False
                    _g22 = 0
                    while (_g22 < len(yds)):
                        yd = (yds[_g22] if _g22 >= 0 and _g22 < len(yds) else None)
                        _g22 = (_g22 + 1)
                        if (not section_delimiter_printed):
                            fd.write("\n")
                            section_delimiter_printed = True
                        fd.write((("  yang-data " + HxOverrides.stringOrNull(yd.arg)) + ":\n"))
                        self.print_children((Reflect.field(yd,"i_children") if (python_Boot.hasField(yd,"i_children")) else list()),module,fd,"  ",path,"yang-data",depth,llen,Reflect.field(ctx.opts,"tree_no_expand_uses"),0,Reflect.field(ctx.opts,"modname_prefix"))

    def unexpand_uses(self,i_children):
        res = []
        uses = []
        _g = 0
        while (_g < len(i_children)):
            ch = (i_children[_g] if _g >= 0 and _g < len(i_children) else None)
            _g = (_g + 1)
            i_uses = (Reflect.field(ch,"i_uses") if (python_Boot.hasField(ch,"i_uses")) else list())
            if (len(i_uses) > 0):
                g = (i_uses[0] if 0 < len(i_uses) else None).arg
                if (not Lambda.has(uses,g)):
                    uses.append(g)
                    res.append((i_uses[0] if 0 < len(i_uses) else None))
            else:
                res.append(ch)
        return res

    def print_path(self,pre,post,path,fd,llen):
        print_comps = None
        def _hx_local_4(pre,p,is_first):
            line = ((("null" if pre is None else pre) + "/") + HxOverrides.stringOrNull((p[0] if 0 < len(p) else None)))
            p1 = p[1:None]
            if (len(line) > llen):
                return
            else:
                while ((len(p1) > 0) and ((((len(line) + 1) + len((p1[0] if 0 < len(p1) else None))) <= llen))):
                    if ((len(p1) == 1) and (((((len(line) + 1) + len((p1[0] if 0 < len(p1) else None))) + len(post)) > llen))):
                        break
                    line = (("null" if line is None else line) + HxOverrides.stringOrNull((("/" + HxOverrides.stringOrNull((p1[0] if 0 < len(p1) else None))))))
                    p1 = p1[1:None]
            if (len(p1) == 0):
                line = (("null" if line is None else line) + ("null" if post is None else post))
            line = (("null" if line is None else line) + "\n")
            fd.write(line)
            if (len(p1) > 0):
                if is_first:
                    pre1 = " "
                    _g = 1
                    _g1 = (len(pre1) + 2)
                    while (_g < _g1):
                        ii = _g
                        _g = (_g + 1)
                        pre1 = (("null" if pre1 is None else pre1) + " ")
                print_comps(pre,p1,False)
        print_comps = _hx_local_4
        line = (((("null" if pre is None else pre) + " ") + ("null" if path is None else path)) + ("null" if post is None else post))
        if ((llen == 0) or ((len(line) < llen))):
            fd.write((("null" if line is None else line) + "\n"))
        else:
            p = path.split("/")
            if ((p[0] if 0 < len(p) else None) == ""):
                p = p[1:None]
            pre1 = (("null" if pre is None else pre) + " ")
            print_comps(pre1,p,True)

    def print_children(self,i_children,module,fd,prefix,path,mode,depth,llen,no_expand_uses,width,prefix_with_modname = None):
        if (prefix_with_modname is None):
            prefix_with_modname = False
        get_width = None
        def _hx_local_1(w,chs):
            ww = w
            _g = 0
            while (_g < len(chs)):
                ch = (chs[_g] if _g >= 0 and _g < len(chs) else None)
                _g = (_g + 1)
                nlen = None
                if Lambda.has(["choice", "case"],ch.keyword):
                    nlen = (3 + get_width(0,(Reflect.field(ch,"i_children") if (python_Boot.hasField(ch,"i_children")) else list())))
                elif HxOverrides.eq(Reflect.field(((Reflect.field(ch,"i_module") if (python_Boot.hasField(ch,"i_module")) else None)),"i_modulename"),((Reflect.field(module,"i_modulename") if (python_Boot.hasField(module,"i_modulename")) else None))):
                    nlen = len(ch.arg)
                else:
                    nlen = python_Boot._add_dynamic(python_Boot._add_dynamic(Reflect.field(Reflect.field(((Reflect.field(ch,"i_module") if (python_Boot.hasField(ch,"i_module")) else None)),"i_prefix"),"length"),1),len(ch.arg))
                if (nlen > ww):
                    ww = nlen
            return ww
        get_width = _hx_local_1
        if no_expand_uses:
            i_children = self.unexpand_uses(i_children)
        w = (get_width(0,i_children) if ((width == 0)) else width)
        _g = 0
        while (_g < len(i_children)):
            ch = (i_children[_g] if _g >= 0 and _g < len(i_children) else None)
            _g = (_g + 1)
            if ((((ch.keyword == "input") or ((ch.keyword == "output")))) and ((Reflect.field(((Reflect.field(ch,"i_children") if (python_Boot.hasField(ch,"i_children")) else list())),"length") == 0))):
                continue
            last_i = python_internal_ArrayImpl._get(i_children, (len(i_children) - 1))
            newprefix = ((("null" if prefix is None else prefix) + "   ") if (((ch == last_i) or (((last_i.keyword == "output") and ((Reflect.field(((Reflect.field(last_i,"i_children") if (python_Boot.hasField(last_i,"i_children")) else list())),"length") == 0)))))) else (("null" if prefix is None else prefix) + "  |"))
            m = mode
            if (ch.keyword == "input"):
                m = "input"
            elif (ch.keyword == "output"):
                m = "output"
            self.print_node(ch,module,fd,newprefix,path,m,depth,llen,no_expand_uses,w,prefix_with_modname)

    def print_node(self,s,module,fd,prefix,path,mode,depth,llen,no_expand_uses,width,prefix_with_modname = None):
        if (prefix_with_modname is None):
            prefix_with_modname = False
        line = ((("" + HxOverrides.stringOrNull(HxString.substr(prefix,0,(len(prefix) - 1)))) + HxOverrides.stringOrNull(self.get_status_str(s))) + "--")
        brcol = (len(line) + 4)
        name = None
        if HxOverrides.eq(Reflect.field(((Reflect.field(s,"i_module") if (python_Boot.hasField(s,"i_module")) else None)),"i_modulename"),((Reflect.field(module,"i_modulename") if (python_Boot.hasField(module,"i_modulename")) else None))):
            name = s.arg
        elif prefix_with_modname:
            name = ((Std.string(Reflect.field(((Reflect.field(s,"i_module") if (python_Boot.hasField(s,"i_module")) else None)),"i_modulename")) + ":") + HxOverrides.stringOrNull(s.arg))
        else:
            name = ((Std.string(Reflect.field(((Reflect.field(s,"i_module") if (python_Boot.hasField(s,"i_module")) else None)),"i_prefix")) + ":") + HxOverrides.stringOrNull(s.arg))
        flags = self.get_flags_str(s,mode)
        if (s.keyword == "list"):
            name = (("null" if name is None else name) + "*")
            line = (("null" if line is None else line) + HxOverrides.stringOrNull((((("null" if flags is None else flags) + " ") + ("null" if name is None else name)))))
        elif (s.keyword == "container"):
            p = s.search_one("presence")
            if (p is not None):
                name = (("null" if name is None else name) + "!")
            line = (("null" if line is None else line) + HxOverrides.stringOrNull((((("null" if flags is None else flags) + " ") + ("null" if name is None else name)))))
        elif (s.keyword == "choice"):
            m = s.search_one("mandatory")
            if ((m is None) or ((m.arg == "false"))):
                line = (("null" if line is None else line) + HxOverrides.stringOrNull(((((("null" if flags is None else flags) + " (") + ("null" if name is None else name)) + ")?"))))
            else:
                line = (("null" if line is None else line) + HxOverrides.stringOrNull(((((("null" if flags is None else flags) + " (") + ("null" if name is None else name)) + ")"))))
        elif (s.keyword == "case"):
            line = (("null" if line is None else line) + HxOverrides.stringOrNull((((":(" + ("null" if name is None else name)) + ")"))))
            brcol = (brcol + 1)
        else:
            if (s.keyword == "leaf-list"):
                name = (("null" if name is None else name) + "*")
            elif ((((s.keyword == "leaf") and ((((Reflect.field(s,"i_is_key") if (python_Boot.hasField(s,"i_is_key")) else None)) is None))) or ((s.keyword == "anydata"))) or ((s.keyword == "anyxml"))):
                m = s.search_one("mandatory")
                if ((m is None) or ((m.arg == "false"))):
                    name = (("null" if name is None else name) + "?")
            t = self.get_typename(s,prefix_with_modname)
            if (t == ""):
                line = (("null" if line is None else line) + HxOverrides.stringOrNull((((("" + ("null" if flags is None else flags)) + " ") + ("null" if name is None else name)))))
            elif ((llen != 0) and (((((((len(line) + len(flags)) + width) + 1) + len(t)) + 4) > llen))):
                if ((self.get_leafref_path(s) is not None) and (((len(t) + brcol) > llen))):
                    line = (("null" if line is None else line) + HxOverrides.stringOrNull(((((("" + ("null" if flags is None else flags)) + " ") + HxOverrides.stringOrNull(HxString.substr(name,0,(width + 1)))) + "   leafref"))))
                else:
                    line = (("null" if line is None else line) + HxOverrides.stringOrNull((((("" + ("null" if flags is None else flags)) + " ") + ("null" if name is None else name)))))
                    fd.write((("null" if line is None else line) + "\n"))
                    line = (((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(TreePlugin.times(" ",(brcol - len(prefix))))) + " ") + ("null" if t is None else t))
            else:
                line = (("null" if line is None else line) + HxOverrides.stringOrNull((((((("" + ("null" if flags is None else flags)) + " ") + HxOverrides.stringOrNull(HxString.substr(name,0,(width + 1)))) + "   ") + ("null" if t is None else t)))))
        if (s.keyword == "list"):
            if (s.search_one("key") is not None):
                arg = s.search_one("key").arg
                keystr = ((" [" + ("null" if arg is None else arg)) + "]")
                if ((llen != 0) and (((len(line) + len(keystr)) > llen))):
                    fd.write((("null" if line is None else line) + "\n"))
                    line = (("null" if prefix is None else prefix) + HxOverrides.stringOrNull(TreePlugin.times(" ",(brcol - len(prefix)))))
                line = (("null" if line is None else line) + ("null" if keystr is None else keystr))
            else:
                line = (("null" if line is None else line) + " []")
        features = s.search("if-feature")
        _g = []
        _g1 = 0
        while (_g1 < len(features)):
            f = (features[_g1] if _g1 >= 0 and _g1 < len(features) else None)
            _g1 = (_g1 + 1)
            x = f.arg
            _g.append(x)
        featurenames = _g
        if (((Reflect.field(s,"i_augment") if (python_Boot.hasField(s,"i_augment")) else None)) is not None):
            afeatures = Reflect.field(((Reflect.field(s,"i_augment") if (python_Boot.hasField(s,"i_augment")) else None)),"search")("if-feature")
            _g = []
            _g1 = 0
            while (_g1 < len(afeatures)):
                f = (afeatures[_g1] if _g1 >= 0 and _g1 < len(afeatures) else None)
                _g1 = (_g1 + 1)
                if (not Lambda.has(featurenames,f.arg)):
                    x = f.arg
                    _g.append(x)
            (featurenames + _g)
        if (len(featurenames) > 0):
            f = ",".join([python_Boot.toString1(x1,'') for x1 in featurenames])
            fstr = ((" {" + ("null" if f is None else f)) + "}?")
            if ((llen != 0) and (((len(line) + len(fstr)) > llen))):
                fd.write((("null" if line is None else line) + "\n"))
                line = (("null" if prefix is None else prefix) + HxOverrides.stringOrNull(TreePlugin.times(" ",(brcol - len(prefix)))))
            line = (("null" if line is None else line) + ("null" if fstr is None else fstr))
        fd.write((("null" if line is None else line) + "\n"))
        if ((((Reflect.field(s,"i_children") if (python_Boot.hasField(s,"i_children")) else list())) is not None) and ((s.keyword != "uses"))):
            if (depth != 0):
                depth = (depth - 1)
            chs = (Reflect.field(s,"i_children") if (python_Boot.hasField(s,"i_children")) else list())
            if (len(path) > 0):
                _g = []
                _g1 = 0
                while (_g1 < len(chs)):
                    ch = (chs[_g1] if _g1 >= 0 and _g1 < len(chs) else None)
                    _g1 = (_g1 + 1)
                    if (ch.arg == (path[0] if 0 < len(path) else None)):
                        _g.append(ch)
                chs1 = _g
                path = path[1:None]
            if Lambda.has(["choice", "case"],s.keyword):
                self.print_children(chs,module,fd,prefix,path,mode,depth,llen,no_expand_uses,(width - 3),prefix_with_modname)
            else:
                self.print_children(chs,module,fd,prefix,path,mode,depth,llen,no_expand_uses,0,prefix_with_modname)

    def get_status_str(self,s):
        status = s.search_one("status")
        if ((status is None) or ((status.arg == "current"))):
            return "+"
        elif (status.arg == "deprecated"):
            return "x"
        elif (status.arg == "obsolete"):
            return "o"
        else:
            return ""

    def get_flags_str(self,s,mode):
        if (mode == "input"):
            return "-w"
        elif Lambda.has(["rpc", "action"],s.keyword):
            return "-x"
        elif (s.keyword == "notification"):
            return "-n"
        elif (s.keyword == "uses"):
            return "-u"
        elif (((Reflect.field(s,"i_config") if (python_Boot.hasField(s,"i_config")) else None)) == True):
            return "rw"
        elif (((((Reflect.field(s,"i_config") if (python_Boot.hasField(s,"i_config")) else None)) == False) or ((mode == "output"))) or ((mode == "notification"))):
            return "ro"
        else:
            return ""

    def get_leafref_path(self,s):
        t = s.search_one("type")
        if (t is not None):
            if (t.arg == "leafref"):
                return t.search_one("path")
            else:
                return None
        else:
            return None

    def get_typename(self,s,prefix_with_modname = None):
        if (prefix_with_modname is None):
            prefix_with_modname = False
        t = s.search_one("type")
        if (t is not None):
            if (t.arg == "leafref"):
                p = t.search_one("path")
                if (p is not None):
                    target = []
                    curprefix = Reflect.field(((Reflect.field(s,"i_module") if (python_Boot.hasField(s,"i_module")) else None)),"i_prefix")
                    p1 = p.arg
                    _g = 0
                    _g1 = pyangext__Statement_SchemaNodeId_Impl_.get_path(p1)
                    while (_g < len(_g1)):
                        n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                        _g = (_g + 1)
                        prefix = (curprefix if ((pyangext__Statement_NodeId_Impl_.get_prefix(n) is None)) else pyangext__Statement_NodeId_Impl_.get_prefix(n))
                        name = pyangext__Statement_NodeId_Impl_.get_id(n)
                        if (prefix == curprefix):
                            target.append(name)
                        else:
                            if prefix_with_modname:
                                i_prefixes = Reflect.field(((Reflect.field(s,"i_module") if (python_Boot.hasField(s,"i_module")) else None)),"i_prefixes")
                                module_name = None
                                if (prefix in i_prefixes):
                                    module_name = Reflect.field(Reflect.field(Reflect.field(((Reflect.field(s,"i_module") if (python_Boot.hasField(s,"i_module")) else None)),"i_prefixes"),"get")(prefix),"_1")
                                else:
                                    module_name = prefix
                                target.append(((("null" if module_name is None else module_name) + ":") + ("null" if name is None else name)))
                            else:
                                target.append(((("null" if prefix is None else prefix) + ":") + ("null" if name is None else name)))
                            curprefix = prefix
                    return (("-> " + HxOverrides.stringOrNull((("/" if (pyangext__Statement_SchemaNodeId_Impl_.get_absolute(p1)) else "")))) + HxOverrides.stringOrNull("/".join([python_Boot.toString1(x1,'') for x1 in target])))
                elif prefix_with_modname:
                    p = t.arg
                    if (pyangext__Statement_NodeId_Impl_.get_prefix(p) is None):
                        return t.arg
                    else:
                        prefix = pyangext__Statement_NodeId_Impl_.get_prefix(p)
                        name = pyangext__Statement_NodeId_Impl_.get_id(p)
                        i_prefixes = Reflect.field(((Reflect.field(s,"i_module") if (python_Boot.hasField(s,"i_module")) else None)),"i_prefixes")
                        module_name = None
                        if (prefix in i_prefixes):
                            module_name = Reflect.field(Reflect.field(Reflect.field(((Reflect.field(s,"i_module") if (python_Boot.hasField(s,"i_module")) else None)),"i_prefixes"),"get")(prefix),"_1")
                        else:
                            module_name = prefix
                        return ((("null" if module_name is None else module_name) + ":") + ("null" if name is None else name))
                else:
                    return t.arg
            elif prefix_with_modname:
                p = t.arg
                if (pyangext__Statement_NodeId_Impl_.get_prefix(p) is None):
                    return t.arg
                else:
                    prefix = pyangext__Statement_NodeId_Impl_.get_prefix(p)
                    name = pyangext__Statement_NodeId_Impl_.get_id(p)
                    i_prefixes = Reflect.field(((Reflect.field(s,"i_module") if (python_Boot.hasField(s,"i_module")) else None)),"i_prefixes")
                    module_name = None
                    if (prefix in i_prefixes):
                        module_name = Reflect.field(Reflect.field(Reflect.field(((Reflect.field(s,"i_module") if (python_Boot.hasField(s,"i_module")) else None)),"i_prefixes"),"get")(prefix),"_1")
                    else:
                        module_name = prefix
                    return ((("null" if module_name is None else module_name) + ":") + ("null" if name is None else name))
            else:
                return t.arg
        elif (s.keyword == "anydata"):
            return "<anydata>"
        elif (s.keyword == "anyxml"):
            return "<anyxml>"
        else:
            return ""

    @staticmethod
    def times(_hx_str,n):
        _g = []
        _g1 = 0
        _g2 = n
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(_hx_str)
        return "".join([python_Boot.toString1(x1,'') for x1 in _g])




class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e



class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(Std.string(value),previous,native)
        self.value = value

    def unwrap(self):
        return self.value



class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()



class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()



class pyangext__Statement_NodeId_Impl_:
    _hx_class_name = "pyangext._Statement.NodeId_Impl_"
    __slots__ = ()
    _hx_statics = ["get_prefix", "get_id"]
    prefix = None
    id = None

    @staticmethod
    def get_prefix(this1):
        startIndex = None
        idx = (this1.find(":") if ((startIndex is None)) else HxString.indexOfImpl(this1,":",startIndex))
        if (idx == -1):
            return None
        else:
            return HxString.substring(this1,0,idx)

    @staticmethod
    def get_id(this1):
        startIndex = None
        idx = (this1.find(":") if ((startIndex is None)) else HxString.indexOfImpl(this1,":",startIndex))
        if (idx == -1):
            return this1
        else:
            return HxString.substring(this1,(idx + 1),None)


class pyangext__Statement_SchemaNodeId_Impl_:
    _hx_class_name = "pyangext._Statement.SchemaNodeId_Impl_"
    __slots__ = ()
    _hx_statics = ["get_absolute", "get_path"]
    absolute = None
    path = None

    @staticmethod
    def get_absolute(this1):
        if ((("" if ((0 >= len(this1))) else this1[0])) == "/"):
            return True
        else:
            return False

    @staticmethod
    def get_path(this1):
        relative = (HxString.substring(this1,1,None) if (pyangext__Statement_SchemaNodeId_Impl_.get_absolute(this1)) else this1)
        return relative.split("/")


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "_add_dynamic", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def _add_dynamic(a,b):
        if (isinstance(a,str) and isinstance(b,str)):
            return (a + b)
        if (isinstance(a,str) or isinstance(b,str)):
            return (python_Boot.toString1(a,"") + python_Boot.toString1(b,""))
        return (a + b)

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            if hasattr(o,field1):
                return getattr(o,field1)
            else:
                return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        this1 = python_Lib.anonAsDict(d)
        return this1


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "anonToDict", "anonAsDict"]

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["get_length", "concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get"]

    @staticmethod
    def get_length(x):
        return len(x)

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "split", "length", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return haxe_iterators_ArrayIterator(x)
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def split(x,delimiter):
        if isinstance(x,str):
            _this = x
            if (delimiter == ""):
                return list(_this)
            else:
                return _this.split(delimiter)
        return x.split(delimiter)

    @staticmethod
    def length(x):
        if isinstance(x,str):
            return len(x)
        elif isinstance(x,list):
            return len(x)
        return x.length

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)



class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "get_length", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def get_length(s):
        return len(s)

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")